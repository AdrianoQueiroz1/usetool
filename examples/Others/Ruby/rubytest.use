model DateLibrary

class RDate
  attributes
    year : Integer
	month : Integer
	day : Integer
	
  operations
    setDate(y:Integer, m:Integer, d:Integer) = script <<
	  dateValue = Date.new($y, $m, $d)
	  $self.year = dateValue.year
	  $self.month = dateValue.month
	  $self.day = dateValue.day
	>>
	
	addDays(i:Integer) = script <<
	  require 'date'
	  date = Date.new($self.year, $self.month, $self.day) + $i
	  $self.year = date.year
	  $self.month = date.month
	  $self.day = date.day
	>>
	
	addDays2(i:Integer) = script <<
	  $self.addDays($i)
	>>
	
	getString() : String = script <<
	  return Date.new($self.year, $self.month, $self.day).to_s
	>>
	
	successor() = script <<
	  $self.day = $self.day + 1
	>>
	
	newDates(amount : Integer) : RDate = script <<
	  1.upto($amount) do |y|
		USE.createObject("d" + y.to_s, "RDate")
	  end
	>>
	
	splitString(pars:Tuple(aString : String, splitChar : String)):Sequence(String) =
	  Sequence{1..pars.aString.size()}->iterate(index ; result : Sequence(String) = Sequence{''} |
		  if pars.aString.substring(index, index) = pars.splitChar then
		    result->including('')
		  else
			let sTemp:String = result->last() in
			  let subSeq:Sequence(String) =  
			    if result->size() = 1 then
				  oclEmpty(Sequence(String))
				else
				  result->subSequence(1, (result->size() - 1))
				endif
			  in
			    subSeq->including(sTemp.concat(pars.aString.substring(index, index)))
		  endif
		)
end