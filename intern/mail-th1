X-From-Line: tharrison@compdata.com Wed Dec 27 17:12:28 2000
Received: from cdsflip ([216.54.232.60])
	by nmh.informatik.uni-bremen.de (8.10.1/8.10.1) with ESMTP id eBRGCR907901
	for <mr@Informatik.Uni-Bremen.DE>; Wed, 27 Dec 2000 17:12:27 +0100 (MET)
Received: by exchange.compdata.com with Internet Mail Service (5.5.2650.21)
	id <Y8CZYWNH>; Wed, 27 Dec 2000 10:09:43 -0600
Received: from exchange.compdata.com ([216.54.232.7])
          by cdsflip (JAMES SMTP Server 1.1b1) with SMTP ID 1020
          for <mr@Informatik.Uni-Bremen.DE>;
          Wed, 27 Dec 2000 10:06:36 -0600
Received: from localhost ([127.0.0.1])
          by cdsflip (JAMES SMTP Server 1.1b1) with SMTP ID 73
          for <mr@Informatik.Uni-Bremen.DE>;
          Wed, 27 Dec 2000 10:06:36 -0600
X-Gnus-Mail-Source: file:/var/mail/mr
Message-ID: <7463136.977933196788.JavaMail.SYSTEM@cdsflip>
From: "Harrison, Tim" <tharrison@compdata.com>
To: "Mark Richters (E-mail)" <mr@Informatik.Uni-Bremen.DE>
Subject: FW: USE 1.4 incorrectly handles oclAsType()
Date: Wed, 27 Dec 2000 10:09:38 -0600
MIME-Version: 1.0
X-Mailer: Internet Mail Service (5.5.2650.21)
Content-Type: multipart/alternative;
	boundary="----_=_NextPart_001_01C0701F.6C6C775E"
X-Yehti: flipped
X-Content-Length: 19478
Lines: 438
Xref: dustbin.informatik.uni-bremen.de mail.misc:3170

------_=_NextPart_001_01C0701F.6C6C775E
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: 7bit

Mark,

In addition to the statements below, section 7.5.9, "Accessing overridden
properties of supertypes," of both UML v1.3 and v1.4 require that one be
able to use oclAsType() to re-type an object to its supertype. This supports
my conjecture that section 7.4.5 is incorrect in its statement that "An
object can only be re-typed to one of its subtype [sic]".

-- Tim

-----Original Message-----
From: Harrison, Tim 
Sent: Friday, December 22, 2000 2:56 PM
To: 'Mark Richters'
Subject: RE: USE 1.4 incorrectly handles oclAsType()


Mark,

I apologize for my previous message. I was obviously confused about the
downcasting. I'd gotten myself into a frame of mind in which I was relying
strictly on how I interpreted the UML v1.3 specification (whether it made
sense or not) and I was misinterpreting. 

UML v1.3 states in section 7.8.1 under the OclAny heading that oclAsType
"Results in Undefined if the actual type of object is not type or one of its
subtypes". I interpret this to say one can re-type an object as its actual
type or any of the supertypes of its actual type, which is what many OO
languages permit. Admittedly, section 7.4.5 says that "An object can only be
re-typed to one of its subtype [sic]" (which I hadn't looked at before
sending you the previous message). I don't think that "FooSub can always be
used where a Foo is expected" is a sufficient reason to forbid upcasting,
because in OCL the type of a Collection literal is determined by the type of
its elements (See example below). Explicit upcasting is useful (needed?) in
Collection literals as shown below and can add clarity to an expression.

OCL problems: Most of my recent difficulties with OCL stem from #1 the lack
of orthogonality between the type hierarchy and type conformance, caused by
the Collection types and #2 the lack of definition for how to determine the
type of a Collection literal. #1 could be improved if oclIsType,
oclIsKindOf, and oclAsType were defined for Collection types, using
conformance to describe what is valid. #2 could be improved by permitting
either (a) explicit type definition for Collection literals, which could
then enable one to write typed empty Collection literals (getting rid of the
need for the USE oclEmpty extension to OCL) and to have elements that are
subtypes of the element type of a Collection literal or (b) permit upcasting
(in conjunction with the solution for #1).

Below is an example of the difficulties created by #1 and #2 above. Neither
of the currently permissible USE invariant statements below are a direct
reflection of the Prose invariant statement. Either the ability to upcast an
object or the ability to explicitly specify the type of a Collection literal
would enable a more direct mapping from the Prose invariant statement in the
OCL invariant statement.

-- begin foobar model
model foobar

class Foo
end

class Foo1 < Foo
end

class Foo2 < Foo
end

class FooBar
attributes
  foo : Foo;
  foo1 : Foo1;
  foo2 : Foo2;
  fooSet : Set(Foo);
constraints
-- It is difficult to say the following
-- Prose invariant : fooSet contains only the elements foo1 and foo2
  --inv : fooSet = Set(Foo){foo1, foo2} -- Not OK, neither UML v1.3
conformant nor USE v1.4 conformant
  inv : fooSet = Set{foo1, foo2} -- Not OK, in USE 1.4 all elements must be
of the same type
  inv : fooSet = Set{foo1.oclAsType(Foo), foo2.oclAsType(Foo)} -- Not OK,
upcast not permitted
  inv : fooSet = (Set{foo} - Set{foo}) -> including(foo1) -> including(foo2)
-- OK, but verbose and non-intuitive
  inv : fooSet = oclEmpty(Set(Foo)) -> including(foo1) -> including(foo2) --
OK, but verbose and not UML v1.3 comformant
end
-- end foobar model

-- Tim Harrison

-----Original Message-----
From: Mark Richters [mailto:mr@Informatik.Uni-Bremen.DE]
Sent: Thursday, December 21, 2000 9:22 AM
To: Harrison, Tim
Subject: Re: USE 1.4 incorrectly handles oclAsType()


Tim,

I think you are confusing things here.

> In the following model FooSub is a subtype of Foo. So, one should be
> able to convert a SubFoo into a Foo using the oclAsType()
> operation. 

A FooSub can always be used where a Foo is expected. There's no
conversion necessary. This is the general OO principle of
subtyping/subclassing.

> However, it appears that the USE compiler is computing
> the operation backwards. It is permitting a type to be converted to
> a subtype (which shouldn't be permitted) and not permitting a type
> to be converted to its supertype (which should be permitted).

A variable of type T can hold a value of any of its subtypes. In
particular, a Foo variable (or attribute) can be assigned a value of
type FooSub.

I have modified your example and made some comments.

--- test.use ---
model foobar

class Foo
attributes
  fooInt : Integer;
end

class FooSub < Foo
attributes
  fooSubInt : Integer;
end

class Foobar
attributes
  foo : Foo;
  fooSub : FooSub;
constraints
  inv : foo.oclAsType(Foo).fooInt = 1 -- oclAsType redundant
  inv : foo.oclAsType(FooSub).fooSubInt = 1 -- oclAsType may fail
  inv : fooSub.fooInt = 1 -- CHANGED: always correct, fooSub "is a" Foo
  inv : fooSub.oclAsType(FooSub).fooSubInt = 1 -- oclAsType redundant
end
--- test.use ---

Here is an example script. Note the place where an object of type
FooSub is assigned to the attribute foo.

--- test.cmd ---
!create foobar1:Foobar
!create foo1:Foo
!create fooSub1:FooSub
!set foobar1.foo = fooSub1
--- test.cmd ---

Some expressions:

?foo1.oclAsType(FooSub)
-> Undefined : FooSub

foo1 is only a Foo. The downcast fails, and the result is undefined.

?foobar1.foo.oclAsType(FooSub)
-> @fooSub1 : FooSub

foobar1.foo is declared as Foo but actually holds a FooSub. The
downcast succeeds, and the result is well-defined.

Regards, Mark

PS: Unfortunately, the script test.cmd triggered another bug in
USE. You will need to apply the following patch, if you want to try
the script.

Index: 1-4-0-release.1/src/org/tzi/use/uml/sys/cmd/MCmdSetAttribute.java
--- 1-4-0-release.1/src/org/tzi/use/uml/sys/cmd/MCmdSetAttribute.java Fri,
27 Oct 2000 18:52:18 +0200 mr (use/f/14_CmdSetAttr 1.14 644)
+++ 0.169(w)/src/org/tzi/use/uml/sys/cmd/MCmdSetAttribute.java Thu, 21 Dec
2000 15:36:34 +0100 mr (use/f/14_CmdSetAttr 1.15 644)
@@ -94,7 +94,7 @@
 
 	// evaluate expression
 	try { 
-	    Value newValue = new Evaluator().eval(fExpr, fSystemState);
+	    Value newValue = new Evaluator().eval(fExpr, fSystemState,
varBindings);
 
 	    // save state for undo
 	    fUndoAttrValue = objState.attributeValue(attr);
Index: 1-4-0-release.1/src/org/tzi/use/parser/USECompiler.java
--- 1-4-0-release.1/src/org/tzi/use/parser/USECompiler.java Sat, 04 Nov 2000
22:07:18 +0100 mr (use/f/42_USECompile 1.13 644)
+++ 0.169(w)/src/org/tzi/use/parser/USECompiler.java Thu, 21 Dec 2000
15:32:47 +0100 mr (use/f/42_USECompile 1.13 644)
@@ -161,7 +161,7 @@
 	    if ( parser.errorCount() == 0 ) {
 
 		// Generate code
-		Context ctx = new Context(inName, err, null, null);
+		Context ctx = new Context(inName, err,
systemState.varBindings(), null);
 		ctx.setModel(model);
 		ctx.setSystemState(systemState);
 		cmdList = astCmdList.gen(ctx);


-- 
Mark Richters (mr@informatik.uni-bremen.de)

------_=_NextPart_001_01C0701F.6C6C775E
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: 7bit

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="MS Exchange Server version 5.5.2650.12">
<TITLE>FW: USE 1.4 incorrectly handles oclAsType()</TITLE>
</HEAD>
<BODY>

<P><FONT SIZE=2>Mark,</FONT>
</P>

<P><FONT SIZE=2>In addition to the statements below, section 7.5.9, &quot;Accessing overridden properties of supertypes,&quot; of both UML v1.3 and v1.4 require that one be able to use oclAsType() to re-type an object to its supertype. This supports my conjecture that section 7.4.5 is incorrect in its statement that &quot;An object can only be re-typed to one of its subtype [sic]&quot;.</FONT></P>

<P><FONT SIZE=2>-- Tim</FONT>
</P>

<P><FONT SIZE=2>-----Original Message-----</FONT>
<BR><FONT SIZE=2>From: Harrison, Tim </FONT>
<BR><FONT SIZE=2>Sent: Friday, December 22, 2000 2:56 PM</FONT>
<BR><FONT SIZE=2>To: 'Mark Richters'</FONT>
<BR><FONT SIZE=2>Subject: RE: USE 1.4 incorrectly handles oclAsType()</FONT>
</P>
<BR>

<P><FONT SIZE=2>Mark,</FONT>
</P>

<P><FONT SIZE=2>I apologize for my previous message. I was obviously confused about the downcasting. I'd gotten myself into a frame of mind in which I was relying strictly on how I interpreted the UML v1.3 specification (whether it made sense or not) and I was misinterpreting. </FONT></P>

<P><FONT SIZE=2>UML v1.3 states in section 7.8.1 under the OclAny heading that oclAsType &quot;Results in Undefined if the actual type of object is not type or one of its subtypes&quot;. I interpret this to say one can re-type an object as its actual type or any of the supertypes of its actual type, which is what many OO languages permit. Admittedly, section 7.4.5 says that &quot;An object can only be re-typed to one of its subtype [sic]&quot; (which I hadn't looked at before sending you the previous message). I don't think that &quot;FooSub can always be used where a Foo is expected&quot; is a sufficient reason to forbid upcasting, because in OCL the type of a Collection literal is determined by the type of its elements (See example below). Explicit upcasting is useful (needed?) in Collection literals as shown below and can add clarity to an expression.</FONT></P>

<P><FONT SIZE=2>OCL problems: Most of my recent difficulties with OCL stem from #1 the lack of orthogonality between the type hierarchy and type conformance, caused by the Collection types and #2 the lack of definition for how to determine the type of a Collection literal. #1 could be improved if oclIsType, oclIsKindOf, and oclAsType were defined for Collection types, using conformance to describe what is valid. #2 could be improved by permitting either (a) explicit type definition for Collection literals, which could then enable one to write typed empty Collection literals (getting rid of the need for the USE oclEmpty extension to OCL) and to have elements that are subtypes of the element type of a Collection literal or (b) permit upcasting (in conjunction with the solution for #1).</FONT></P>

<P><FONT SIZE=2>Below is an example of the difficulties created by #1 and #2 above. Neither of the currently permissible USE invariant statements below are a direct reflection of the Prose invariant statement. Either the ability to upcast an object or the ability to explicitly specify the type of a Collection literal would enable a more direct mapping from the Prose invariant statement in the OCL invariant statement.</FONT></P>

<P><FONT SIZE=2>-- begin foobar model</FONT>
<BR><FONT SIZE=2>model foobar</FONT>
</P>

<P><FONT SIZE=2>class Foo</FONT>
<BR><FONT SIZE=2>end</FONT>
</P>

<P><FONT SIZE=2>class Foo1 &lt; Foo</FONT>
<BR><FONT SIZE=2>end</FONT>
</P>

<P><FONT SIZE=2>class Foo2 &lt; Foo</FONT>
<BR><FONT SIZE=2>end</FONT>
</P>

<P><FONT SIZE=2>class FooBar</FONT>
<BR><FONT SIZE=2>attributes</FONT>
<BR><FONT SIZE=2>&nbsp; foo : Foo;</FONT>
<BR><FONT SIZE=2>&nbsp; foo1 : Foo1;</FONT>
<BR><FONT SIZE=2>&nbsp; foo2 : Foo2;</FONT>
<BR><FONT SIZE=2>&nbsp; fooSet : Set(Foo);</FONT>
<BR><FONT SIZE=2>constraints</FONT>
<BR><FONT SIZE=2>-- It is difficult to say the following</FONT>
<BR><FONT SIZE=2>-- Prose invariant : fooSet contains only the elements foo1 and foo2</FONT>
<BR><FONT SIZE=2>&nbsp; --inv : fooSet = Set(Foo){foo1, foo2} -- Not OK, neither UML v1.3 conformant nor USE v1.4 conformant</FONT>
<BR><FONT SIZE=2>&nbsp; inv : fooSet = Set{foo1, foo2} -- Not OK, in USE 1.4 all elements must be of the same type</FONT>
<BR><FONT SIZE=2>&nbsp; inv : fooSet = Set{foo1.oclAsType(Foo), foo2.oclAsType(Foo)} -- Not OK, upcast not permitted</FONT>
<BR><FONT SIZE=2>&nbsp; inv : fooSet = (Set{foo} - Set{foo}) -&gt; including(foo1) -&gt; including(foo2) -- OK, but verbose and non-intuitive</FONT>
<BR><FONT SIZE=2>&nbsp; inv : fooSet = oclEmpty(Set(Foo)) -&gt; including(foo1) -&gt; including(foo2) -- OK, but verbose and not UML v1.3 comformant</FONT></P>

<P><FONT SIZE=2>end</FONT>
<BR><FONT SIZE=2>-- end foobar model</FONT>
</P>

<P><FONT SIZE=2>-- Tim Harrison</FONT>
</P>

<P><FONT SIZE=2>-----Original Message-----</FONT>
<BR><FONT SIZE=2>From: Mark Richters [<A HREF="mailto:mr@Informatik.Uni-Bremen.DE">mailto:mr@Informatik.Uni-Bremen.DE</A>]</FONT>
<BR><FONT SIZE=2>Sent: Thursday, December 21, 2000 9:22 AM</FONT>
<BR><FONT SIZE=2>To: Harrison, Tim</FONT>
<BR><FONT SIZE=2>Subject: Re: USE 1.4 incorrectly handles oclAsType()</FONT>
</P>
<BR>

<P><FONT SIZE=2>Tim,</FONT>
</P>

<P><FONT SIZE=2>I think you are confusing things here.</FONT>
</P>

<P><FONT SIZE=2>&gt; In the following model FooSub is a subtype of Foo. So, one should be</FONT>
<BR><FONT SIZE=2>&gt; able to convert a SubFoo into a Foo using the oclAsType()</FONT>
<BR><FONT SIZE=2>&gt; operation. </FONT>
</P>

<P><FONT SIZE=2>A FooSub can always be used where a Foo is expected. There's no</FONT>
<BR><FONT SIZE=2>conversion necessary. This is the general OO principle of</FONT>
<BR><FONT SIZE=2>subtyping/subclassing.</FONT>
</P>

<P><FONT SIZE=2>&gt; However, it appears that the USE compiler is computing</FONT>
<BR><FONT SIZE=2>&gt; the operation backwards. It is permitting a type to be converted to</FONT>
<BR><FONT SIZE=2>&gt; a subtype (which shouldn't be permitted) and not permitting a type</FONT>
<BR><FONT SIZE=2>&gt; to be converted to its supertype (which should be permitted).</FONT>
</P>

<P><FONT SIZE=2>A variable of type T can hold a value of any of its subtypes. In</FONT>
<BR><FONT SIZE=2>particular, a Foo variable (or attribute) can be assigned a value of</FONT>
<BR><FONT SIZE=2>type FooSub.</FONT>
</P>

<P><FONT SIZE=2>I have modified your example and made some comments.</FONT>
</P>

<P><FONT SIZE=2>--- test.use ---</FONT>
<BR><FONT SIZE=2>model foobar</FONT>
</P>

<P><FONT SIZE=2>class Foo</FONT>
<BR><FONT SIZE=2>attributes</FONT>
<BR><FONT SIZE=2>&nbsp; fooInt : Integer;</FONT>
<BR><FONT SIZE=2>end</FONT>
</P>

<P><FONT SIZE=2>class FooSub &lt; Foo</FONT>
<BR><FONT SIZE=2>attributes</FONT>
<BR><FONT SIZE=2>&nbsp; fooSubInt : Integer;</FONT>
<BR><FONT SIZE=2>end</FONT>
</P>

<P><FONT SIZE=2>class Foobar</FONT>
<BR><FONT SIZE=2>attributes</FONT>
<BR><FONT SIZE=2>&nbsp; foo : Foo;</FONT>
<BR><FONT SIZE=2>&nbsp; fooSub : FooSub;</FONT>
<BR><FONT SIZE=2>constraints</FONT>
<BR><FONT SIZE=2>&nbsp; inv : foo.oclAsType(Foo).fooInt = 1 -- oclAsType redundant</FONT>
<BR><FONT SIZE=2>&nbsp; inv : foo.oclAsType(FooSub).fooSubInt = 1 -- oclAsType may fail</FONT>
<BR><FONT SIZE=2>&nbsp; inv : fooSub.fooInt = 1 -- CHANGED: always correct, fooSub &quot;is a&quot; Foo</FONT>
<BR><FONT SIZE=2>&nbsp; inv : fooSub.oclAsType(FooSub).fooSubInt = 1 -- oclAsType redundant</FONT>
<BR><FONT SIZE=2>end</FONT>
<BR><FONT SIZE=2>--- test.use ---</FONT>
</P>

<P><FONT SIZE=2>Here is an example script. Note the place where an object of type</FONT>
<BR><FONT SIZE=2>FooSub is assigned to the attribute foo.</FONT>
</P>

<P><FONT SIZE=2>--- test.cmd ---</FONT>
<BR><FONT SIZE=2>!create foobar1:Foobar</FONT>
<BR><FONT SIZE=2>!create foo1:Foo</FONT>
<BR><FONT SIZE=2>!create fooSub1:FooSub</FONT>
<BR><FONT SIZE=2>!set foobar1.foo = fooSub1</FONT>
<BR><FONT SIZE=2>--- test.cmd ---</FONT>
</P>

<P><FONT SIZE=2>Some expressions:</FONT>
</P>

<P><FONT SIZE=2>?foo1.oclAsType(FooSub)</FONT>
<BR><FONT SIZE=2>-&gt; Undefined : FooSub</FONT>
</P>

<P><FONT SIZE=2>foo1 is only a Foo. The downcast fails, and the result is undefined.</FONT>
</P>

<P><FONT SIZE=2>?foobar1.foo.oclAsType(FooSub)</FONT>
<BR><FONT SIZE=2>-&gt; @fooSub1 : FooSub</FONT>
</P>

<P><FONT SIZE=2>foobar1.foo is declared as Foo but actually holds a FooSub. The</FONT>
<BR><FONT SIZE=2>downcast succeeds, and the result is well-defined.</FONT>
</P>

<P><FONT SIZE=2>Regards, Mark</FONT>
</P>

<P><FONT SIZE=2>PS: Unfortunately, the script test.cmd triggered another bug in</FONT>
<BR><FONT SIZE=2>USE. You will need to apply the following patch, if you want to try</FONT>
<BR><FONT SIZE=2>the script.</FONT>
</P>

<P><FONT SIZE=2>Index: 1-4-0-release.1/src/org/tzi/use/uml/sys/cmd/MCmdSetAttribute.java</FONT>
<BR><FONT SIZE=2>--- 1-4-0-release.1/src/org/tzi/use/uml/sys/cmd/MCmdSetAttribute.java Fri, 27 Oct 2000 18:52:18 +0200 mr (use/f/14_CmdSetAttr 1.14 644)</FONT></P>

<P><FONT SIZE=2>+++ 0.169(w)/src/org/tzi/use/uml/sys/cmd/MCmdSetAttribute.java Thu, 21 Dec 2000 15:36:34 +0100 mr (use/f/14_CmdSetAttr 1.15 644)</FONT></P>

<P><FONT SIZE=2>@@ -94,7 +94,7 @@</FONT>
<BR><FONT SIZE=2>&nbsp;</FONT>
<BR><FONT SIZE=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // evaluate expression</FONT>
<BR><FONT SIZE=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try { </FONT>
<BR><FONT SIZE=2>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Value newValue = new Evaluator().eval(fExpr, fSystemState);</FONT>
<BR><FONT SIZE=2>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Value newValue = new Evaluator().eval(fExpr, fSystemState, varBindings);</FONT>
<BR><FONT SIZE=2>&nbsp;</FONT>
<BR><FONT SIZE=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // save state for undo</FONT>
<BR><FONT SIZE=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fUndoAttrValue = objState.attributeValue(attr);</FONT>
<BR><FONT SIZE=2>Index: 1-4-0-release.1/src/org/tzi/use/parser/USECompiler.java</FONT>
<BR><FONT SIZE=2>--- 1-4-0-release.1/src/org/tzi/use/parser/USECompiler.java Sat, 04 Nov 2000 22:07:18 +0100 mr (use/f/42_USECompile 1.13 644)</FONT></P>

<P><FONT SIZE=2>+++ 0.169(w)/src/org/tzi/use/parser/USECompiler.java Thu, 21 Dec 2000 15:32:47 +0100 mr (use/f/42_USECompile 1.13 644)</FONT>
<BR><FONT SIZE=2>@@ -161,7 +161,7 @@</FONT>
<BR><FONT SIZE=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ( parser.errorCount() == 0 ) {</FONT>
<BR><FONT SIZE=2>&nbsp;</FONT>
<BR><FONT SIZE=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Generate code</FONT>
<BR><FONT SIZE=2>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Context ctx = new Context(inName, err, null, null);</FONT>
<BR><FONT SIZE=2>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Context ctx = new Context(inName, err, systemState.varBindings(), null);</FONT>
<BR><FONT SIZE=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx.setModel(model);</FONT>
<BR><FONT SIZE=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx.setSystemState(systemState);</FONT>
<BR><FONT SIZE=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdList = astCmdList.gen(ctx);</FONT>
</P>
<BR>

<P><FONT SIZE=2>-- </FONT>
<BR><FONT SIZE=2>Mark Richters (mr@informatik.uni-bremen.de)</FONT>
</P>

<A href="http://cdsflip.compdata.com:7230/impression/servlet/Click?transformID=12602&url=http://www.compdata.com"><IMG src="http://cdsflip.compdata.com:7230/impression/servlet/Impression?transformID=12602&low=http://cdsflip.compdata.com/yehti/media//CDS_Logo2.jpg"></A></BODY>
</HTML>
------_=_NextPart_001_01C0701F.6C6C775E--



