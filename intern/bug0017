$Bug: Deleting a heterogenous set of objects is not possible.$
$Category: GUI$
$State: Closed$
$BugAuthor: gutsche$
$Tests: test/t018, MCmdDestroyObjectsTest$


Hallo Mark,

> Das kann ich nicht ganz nachvollziehen. Ich habe mal mit test/t012.use
> probiert und kann im GUI als auch in der shell mehrere Objekte
> gleichzeit loeschen. Hast Du vielleicht ein konkretes Beispiel?
>  
>
folgende Schritte habe ich durchgeführt (die jeweiligen Versuche 
sind als cmd-File angehangen):

open test/t012.use   (destroyExample)
!create A1 : A
!create B1 : B
!destroy A1, B1
<input>:1:11: unexpected token: ,

Es ist zwar möglich über eine Collection zwei Objekte vom gleichen 
Typ zu löschen, aber nicht zwei  Objekte von verschiedenen Typen:

Löschen von Objekten mit gleichen Typ:
open test/t012.use   (destroyWithSequenceSameTypes)
!create A1 : A
!create A2 : A
!destroy Sequence {A1,A2}

Löschen von Objekten mit ungleichen Typen:
open test/t012.use   (destroyWithSequenceDifferentTypes)
!create A1 : A
!create B1 : B
!destroy Sequence {A1,B1}
<input>:1:9: Expected expression of object or collection type, found `Sequence(OclAny)'.
Der Fehler tritt, wie erwartet bei jeder Collection auf.

Die Grammatik in der use.g verstehe ich so, dass nur eine 'expression' 
von Objekten gelöscht werden kann. Es mag gut sein, dass ich einen 
Fehler beim Löschen mache. Aber das Einzige, das bei mir zum Erfolg 
führte war das Löschen von gleichen Objekten in einer Collection.  
In USE-2.0.1 war es allerdings immer möglich verschiedene Objekte in 
einer Komma getrennten Liste zu löschen (genau wie mein erster Versuch 
siehe 'destroyExample').

In der GUI habe ich mit Hilfe von dem destroyExample.cmd die Objekte 
erzeugt und dann beide Objekte selektiert und versucht zu löschen. Es 
erschien die gleiche Fehlermeldung wie auf der Konsole. Eine Screenshot 
habe ich angehangen (destroyExample.jpg).

Ich hoffe du kannst mir jetzt weiterhelfen.

Bis dann,
Fabian.





Hallo Fabian,

dank Deiner ausfuehrlichen Beschreibung verstehe ich das Problem
jetzt. Den Fall mit Objekten verschiedener Typen hatte ich offenbar
nicht bedacht. Ich wuerde zur Loesung vorschlagen, die Syntax fuer das
destroy Kommando so zu aendern, dass eine Liste von expressions
moeglich ist:

  destroyCmd ::= "destroy" expression { "," expression }

Damit muesste man eigentlich beides abdecken koennen, eine Liste so
wie es vorher ging, als auch komplexere Ausdruecke. Fuer Objekte
unterschiedlichen Typs muss man dann eben die Listenform angeben.


>> Es ist zwar möglich über eine Collection zwei Objekte vom gleichen Typ
>> zu löschen, aber nicht zwei Objekte von verschiedenen Typen:


Hm, der Test in ASTDestroyCmd

	if ( t.isObjectType() 
	     || ( t.isCollection() && ((CollectionType) t).elemType().isObjectType()) )

verleitet mich zu der etwas pingeligen Feststellung: ... sofern nicht
ein gemeinsamer Obertyp existiert, der wiederum ein Objekttyp
ist. Aber Du hast natuerlich insgesamt recht, dass das keine
vernuenftige Loesung ist.


>> In der GUI habe ich mit Hilfe von dem destroyExample die Objekte
>> erzeugt und dann beide Objekte selektiert und versucht zu löschen. Es
>> erschien die gleiche Fehlermeldung wie auf der Konsole.


Der Fehler im GUI liegt daran, dass intern immer noch ein
destroy-Kommando nach alter (2.0.1) Syntax erzeugt wird, also eine
Liste. Klarer bug in NewObjectDiagramView:

    /**
     * Executes a command for deleting selected objects.
     */
    void deleteObjects(Set objects) {
	String cmd = "destroy " + StringUtil.fmtSeq(objects.iterator(), ",");
	fMainWindow.execCmd(cmd);
    }

Wenn man die Syntax wie oben vorgeschlagen aendert, koennte man das
sogar so lassen 

Gruesse, Mark
-- Mark Richters mr(at)mrichters.de 
